/*
 * Copyright 2016 Toradex AG
 *
 * This file is dual-licensed: you can use it either under the terms
 * of the GPL or the X11 license, at your option. Note that this dual
 * licensing only applies to this file, and not this project as a
 * whole.
 *
 *  a) This file is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU General Public License as
 *     published by the Free Software Foundation; either version 2 of the
 *     License, or (at your option) any later version.
 *
 *     This file is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 * Or, alternatively,
 *
 *  b) Permission is hereby granted, free of charge, to any person
 *     obtaining a copy of this software and associated documentation
 *     files (the "Software"), to deal in the Software without
 *     restriction, including without limitation the rights to use,
 *     copy, modify, merge, publish, distribute, sublicense, and/or
 *     sell copies of the Software, and to permit persons to whom the
 *     Software is furnished to do so, subject to the following
 *     conditions:
 *
 *     The above copyright notice and this permission notice shall be
 *     included in all copies or substantial portions of the Software.
 *
 *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 *     OTHER DEALINGS IN THE SOFTWARE.
 */

/ {
	aliases {
		rtc0 = &snvs_rtc;
		rtc1 = &rtc;
	};

	chosen {
		stdout-path = "serial0:115200n8";
	};

	/* fixed crystal dedicated to mcp251x */
	clk16m: clk16m {
		compatible = "fixed-clock";
		#clock-cells = <0>;
		clock-frequency = <16000000>;
	};

	extcon_usbc_det: usbc_det {
		compatible = "linux,extcon-usb-gpio";
		debounce = <25>;
		id-gpio = <&gpio7 14 GPIO_ACTIVE_HIGH>;
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_usbc_det>;
	};

	reg_3v3: regulator-3v3 {
		compatible = "regulator-fixed";
		regulator-name = "3.3V";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
	};

	reg_5v0: regulator-5v0 {
		compatible = "regulator-fixed";
		regulator-name = "5V";
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
	};

	reg_usbh_vbus: regulator-usbh-vbus {
		compatible = "regulator-fixed";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_usbh_reg>;
		regulator-name = "VCC_USB[1-4]";
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		gpio = <&gpio4 7 GPIO_ACTIVE_LOW>;
		vin-supply = <&reg_5v0>;
	};

	/* Remove sound module */
	/delete-node/sound;

};

&bl {
	/* Use PWM_B for backlight */
	/* last value is for polarity: 0-normal, 1-inverted */
	pwms = <&pwm2 0 5000000 1>;

	/* GPIO to enable backlight on 1370-C is GPIO4_IO11 - SODIMM 86 */
	enable-gpios = <&gpio4 11 GPIO_ACTIVE_HIGH>;

	/* 6 levels inverted for 1370 board with backlight reduced by PWM */
	/* At level 0, the driver uses the enable gpio to stop the backlight and the PWM is disabled */
	brightness-levels = <0 30 50 100 170 255>;
	default-brightness-level = <5>;
	power-supply = <&reg_3v3>;

	status = "okay";
};

&adc1 {
	status = "okay";
};

&adc2 {
	status = "okay";
};

&epxp {
	status = "okay";
};

&fec1 {
	status = "okay";
};


/*
	fec1 configuration from imx7s.dtsi, imx7-colibri.dtsi, imx7-colibri-1370.dtsi gives:
		compatible = "fsl,imx7d-fec", "fsl,imx6sx-fec";
		reg = <0x30be0000 0x10000>;
		interrupts = <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>,
			<GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>,
			<GIC_SPI 120 IRQ_TYPE_LEVEL_HIGH>;
		clocks = <&clks IMX7D_ENET_AXI_ROOT_CLK>,
			<&clks IMX7D_ENET_AXI_ROOT_CLK>,
			<&clks IMX7D_ENET1_TIME_ROOT_CLK>,
			<&clks IMX7D_PLL_ENET_MAIN_50M_CLK>;
		clock-names = "ipg", "ahb", "ptp", "enet_clk_ref";
		fsl,num-tx-queues=<3>;
		fsl,num-rx-queues=<3>;
		status = "okay";
		pinctrl-names = "default", "sleep";
		pinctrl-0 = <&pinctrl_enet1>;
		pinctrl-1 = <&pinctrl_enet1_sleep>;
		assigned-clocks = <&clks IMX7D_ENET1_TIME_ROOT_SRC>, <&clks IMX7D_ENET1_TIME_ROOT_CLK>;
		assigned-clock-parents = <&clks IMX7D_PLL_ENET_MAIN_100M_CLK>;
		assigned-clock-rates = <0>, <100000000>;
		phy-mode = "rmii";
		phy-supply = <&reg_LDO1>;
		fsl,magic-packet;

	fec2 configuration from imx7d.dtsi gives:
		compatible = "fsl,imx7d-fec", "fsl,imx6sx-fec";
		reg = <0x30bf0000 0x10000>;
		interrupts = <GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>,
			<GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>,
			<GIC_SPI 102 IRQ_TYPE_LEVEL_HIGH>;
		clocks = <&clks IMX7D_ENET2_IPG_ROOT_CLK>,
			<&clks IMX7D_ENET_AXI_ROOT_CLK>,
			<&clks IMX7D_ENET2_TIME_ROOT_CLK>,
			<&clks IMX7D_PLL_ENET_MAIN_125M_CLK>,
			<&clks IMX7D_ENET_PHY_REF_ROOT_DIV>;
		clock-names = "ipg", "ahb", "ptp",
			"enet_clk_ref", "enet_out";
		fsl,num-tx-queues=<3>;
		fsl,num-rx-queues=<3>;
		status = "disabled";

		We customize it to:
		- get our pinctrl configuration to select proper pin
		- select phy rmii mode
		- enable the fec2 interface
		- enable fsl,magic-packet to be able to wake-up controller with a magic packet
		- enable fsl,mii-exclusive to use a dedicated sdio per fec interface
		- properly set clocks:
			- same as the fec1 clocks (ipg, ahb and ptp values not clear, probably coming from ethernet controller requirements). The default imx7d.dtsi clock settings for fec2 are for gigabyte ethernet PHY.
			- don't reuse the same clocks as fec1 to avoid interferences
			- pinctrl_enet2 settings comes from a forum, it is not clear why the SION bit is required for MX7D_PAD_I2C2_SCL__CCM_ENET_REF_CLK2
*/
&fec2 {
	pinctrl-names = "default", "sleep";
	pinctrl-0 = <&pinctrl_enet2>;
	pinctrl-1 = <&pinctrl_enet2_sleep>;

	clocks = <&clks IMX7D_ENET2_IPG_ROOT_CLK>,
		<&clks IMX7D_ENET_AXI_ROOT_CLK>,
		<&clks IMX7D_ENET2_TIME_ROOT_CLK>,
		<&clks IMX7D_PLL_ENET_MAIN_50M_CLK>,
		<&clks IMX7D_ENET2_REF_ROOT_DIV>;
	clock-names = "ipg", "ahb", "ptp", "enet_clk_ref", "enet_out";

	assigned-clocks = 	<&clks IMX7D_ENET2_TIME_ROOT_SRC>,
				<&clks IMX7D_ENET2_TIME_ROOT_CLK>,
				<&clks IMX7D_ENET_PHY_REF_ROOT_DIV>;
	assigned-clock-parents = <&clks IMX7D_PLL_ENET_MAIN_100M_CLK>;
	assigned-clock-rates = <0>, <100000000>, <50000000>;

	phy-mode = "rmii";

	fsl,mii-exclusive;
	fsl,magic-packet;

	status = "okay";
};


&i2c1 {

	/* Remove audio codec */
	/delete-node/sgtl5000@0a;

	/* Remove resistive touchscreen */
	/delete-node/ad7879@2c;

};

&i2c2 {
	clock-frequency = <100000>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_i2c2>;
	status = "okay";

	/* Goodix touchscreen controller */
	goodix: goodix@5d {
		compatible = "goodix,gt911";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_i2ctouch>;
		reg = <0x5d>;
		interrupt-parent = <&gpio5>;
		interrupts = <11 IRQ_TYPE_EDGE_FALLING>; /* (PIN 98) */
		status = "okay";
	};

	/* Cypress touchscreen controller */
	/* Reset and interrupt GPIO set in pinctrl_gpio2 */
	cypress: cypress@24 {
		compatible = "cy,cyttsp5_i2c_adapter";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_i2ctouch>;
		reg = <0x24>;

		interrupt-parent = <&gpio5>;
		interrupts = <11 IRQ_TYPE_EDGE_FALLING>; /* (SODIMM 98 - SD2_RESET_B) - gpio5.11 */
		cy,adapter_id = "cyttsp5_i2c_adapter";

		cy,core {
			cy,name = "cyttsp5_core";

			cy,irq_gpio = <139>; /* (SODIMM 98 - SD2_RESET_B) - gpio5.11 = (5-1) x 32 + 11 = 139 */
			cy,rst_gpio = <114>; /* (SODIMM 79 - ECSPI1_MISO) gpio4.18 = (4-1) x 32 + 18 = 114 */
			cy,hid_desc_register = <1>;
			/*CY_CORE_FLAG_RESTORE_PARAMETERS */
			cy,flags = <4>;
			/* CY_CORE_EWG_NONE */
			cy,easy_wakeup_gesture = <0>;
			cy,btn_keys = <
					60 /* KEY_F2 */
					62 /* KEY_F4 */
					>;
			cy,btn_keys-tag = <0>;

			cy,mt {
				cy,name = "cyttsp5_mt";

				cy,inp_dev_name = "cyttsp5_mt";
				cy,flags = <0x0>;
				cy,abs =
					/* ABS_MT_POSITION_X, CY_ABS_MIN_X, CY_ABS_MAX_X, 0, 0 */
					<0x35 0 320 0 0
					/* ABS_MT_POSITION_Y, CY_ABS_MIN_Y, CY_ABS_MAX_Y, 0, 0 */
					0x36 0 240 0 0
					/* ABS_MT_PRESSURE, CY_ABS_MIN_P, CY_ABS_MAX_P, 0, 0 */
					0x3a 0 255 0 0
					/* CY_IGNORE_VALUE, CY_ABS_MIN_W, CY_ABS_MAX_W, 0, 0 */
					0xffff 0 255 0 0
					/* ABS_MT_TRACKING_ID, CY_ABS_MIN_T, CY_ABS_MAX_T, 0, 0 */
					0x39 0 15 0 0
					/* ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0 */
					0x30 0 255 0 0
					/* ABS_MT_TOUCH_MINOR, 0, 255, 0, 0 */
					0x31 0 255 0 0
					/* ABS_MT_ORIENTATION, -127, 127, 0, 0 */
					0x34 0xffffff81 127 0 0
					/* ABS_MT_TOOL_TYPE, 0, MT_TOOL_MAX, 0, 0 */
					0x37 0 1 0 0
					/* ABS_MT_DISTANCE, 0, 255, 0, 0 */
					0x3b 0 255 0 0>;
			};

			cy,btn {
				cy,name = "cyttsp5_btn";

				cy,inp_dev_name = "cyttsp5_btn";
			};
		};
	};

};

&i2c4 {
	status = "okay";

/* the PCAPs use SODIMM 28/30, also used for PWM<B>, PWM<C>, aka pwm2, pwm3.
   so if you enable one of the PCAP controllers disable the pwms */
	/* Atmel maxtouch controller */
	atmel_mxt_ts: atmel_mxt_ts@4a {
		compatible = "atmel,maxtouch";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_gpiotouch>;
		reg = <0x4a>;
		interrupt-parent = <&gpio1>;
		interrupts = <9 IRQ_TYPE_EDGE_FALLING>; /* SODIMM 28 */
		reset-gpios = <&gpio1 10 GPIO_ACTIVE_HIGH>; /* SODIMM 30 */
		status = "disabled";
	};

	touch: touchrevf0710a@10 {
		compatible = "touchrevolution,fusion-f0710a";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_gpiotouch>;
		reg = <0x10>;
			/* SODIMM 28, Pen down interrupt */
		gpios = <&gpio1 9 GPIO_ACTIVE_HIGH
			/* SODIMM 30, Reset interrupt */
			 &gpio1 10 GPIO_ACTIVE_LOW
			>;
		status = "disabled";
	};

	/* M41T0M6 real time clock on carrier board */
	rtc: m41t0m6@68 {
		compatible = "st,m41t0";
		reg = <0x68>;
	};
};

&lcdif {
	display = <&display0>;
	status = "okay";

	display0: lcd-display {
		bits-per-pixel = <32>;
		bus-width = <18>;

		display-timings {

			native-mode = <&timing_qvga_ips>;

			/* QVGA timing for Jiya 14A99 display with Himax controller from datasheet
			   320x240 pixels
			   Parallel-rgb mode:
			   Dot clock	6.5MHz
			   H Back porch	68 dots -> 58 dots (10 dots removed for HSync)
			   H Front porch 20 dots
			   V Back porch	18 lines -> 16 lines (2 lines removed for VSync)
			   V Front porch 4 lines
			   HSync, VSync and DE active low
			   Pixel clock sample on falling edge
			   HSync and VSync are deduced from Data transaction timing in parallel RGB mode
			   HSync: 10 dots (between 2 and 67 dots)
			   VSync: 2 lines
			*/
			timing_qvga: 320x240 {
				clock-frequency = <6500000>;
				hactive = <320>;
				hfront-porch = <20>;
				hsync-len = <10>;
				hback-porch = <58>;

				vactive = <240>;
				vfront-porch = <4>;
				vsync-len = <2>;
				vback-porch = <16>;

				de-active = <0>;
				hsync-active = <0>;
				vsync-active = <0>;
				pixelclk-active = <0>;

				linux,phandle = <&timing_qvga>;
			};

			/* QVGA timing for Jiya (IPS) display with Sitronix controller from datasheet
			   320x240 pixels
			   Parallel-rgb mode:
			   Dot clock	6MHz
			   H Back porch	43 dots -> 39 dots (4 dots removed for HSync)
			   H Front porch 8 dots
			   V Back porch	12 lines -> 8 lines (4 lines removed for VSync)
			   V Front porch 8 lines
			   HSync, VSync and DE active low
			   Pixel clock sample on falling edge
			   HSync and VSync are deduced from Data transaction timing in parallel RGB mode
			   HSync: 4 dots
			   VSync: 4 lines
			*/
			timing_qvga_ips: 320x240_ips {
				clock-frequency = <6000000>;
				hactive = <320>;
				hfront-porch = <8>;
				hsync-len = <4>;
				hback-porch = <39>;

				vactive = <240>;
				vfront-porch = <8>;
				vsync-len = <4>;
				vback-porch = <8>;

				de-active = <0>;
				hsync-active = <0>;
				vsync-active = <0>;
				pixelclk-active = <0>;

				linux,phandle = <&timing_qvga_ips>;
			};
		};
	};
};

&pwm1 {
	status = "okay";
};

/* the PCAPs use SODIMM 28/30, also used for PWM<B>, PWM<C>, aka pwm2, pwm3.
   so if you enable one of the PCAP controllers disable the pwms */
&pwm2 {
	status = "okay";
};

&pwm3 {
	status = "okay";
};

&pwm4 {
	status = "okay";
};

&uart1 {
	status = "okay";
};

&uart2 {
	status = "okay";
};

/* Disable UART3 because it is not used, so that the pin configuration defined in the node "pinctrl_uart3" of imx7d-colibri.dtsi is not took into account
   By disabling it, we make sure that 
   UART3_RX_DATA is set as GPIO4_IO4, signal USBC_OC in PCB 1370-C
   UART3_TX_DATA is set as GPIO4_IO5, signal USBC_P_EN in PCB 1370-C */
&uart3 {
	status = "disabled";
};

/* This is the USBC of the Colibri intended to be connected to USB Box */
&usbotg1 {
	extcon = <&extcon_usbc_det>, <&extcon_usbc_det>;
	vbus-supply = <&reg_usbh_vbus>;
	status = "okay";
	maximum-speed = "full-speed";		/* Force USBC port (USB Box) to full-speed */
};

/* The define SD_1_8 allows to use the SD interface at a higher speed mode
 * if the card supports it. For this the signaling voltage is switched from
 * 3.3V to 1.8V under the usdhc1's drivers control.
 * All pins supplied with NVCC_SD1 must be able to cope with this
 * and must (MUST!!!) not be driven with a voltage higher than 1.8V or
 * the interface will not work.
 */
/* #define SD_1_8 */
&usdhc1 {
#ifdef SD_1_8
	pinctrl-names = "default", "state_100mhz", "state_200mhz";
	pinctrl-0 = <&pinctrl_usdhc1 &pinctrl_cd_usdhc1>;
	pinctrl-1 = <&pinctrl_usdhc1_100mhz &pinctrl_cd_usdhc1>;
	pinctrl-2 = <&pinctrl_usdhc1_200mhz &pinctrl_cd_usdhc1>;
	vqmmc-supply = <&reg_LDO2>;
#else
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usdhc1 &pinctrl_cd_usdhc1>;
	no-1-8-v;
#endif
	cd-gpios = <&gpio1 0 GPIO_ACTIVE_LOW>;
	disable-wp;
	enable-sdio-wakeup;
	keep-power-in-suspend;
	wakeup-source;
	status = "okay";
	vmmc-supply = <&reg_3v3>;
};

&iomuxc {
	pinctrl_gpiotouch: touchgpios {
		fsl,pins = <
			MX7D_PAD_GPIO1_IO09__GPIO1_IO9		0x74
			MX7D_PAD_GPIO1_IO10__GPIO1_IO10		0x14
		>;
	};


	/*
	 SoC connections for second ethernet
		<SoC pin> <SoC name> (<Function>) -> <PHY pin>

		Pin 122 CRS_DV (RX_CTL) -> RXDV
		Pin 114 RXD0 (RD0) -> RXD0
		Pin 116 RXD1 (RD1) -> RXD1
		Pin 124 RXER (RXC) -> RXER
		Pin 133 TXEN (TX_CTL) -> TXEN
		Pin 127 TXD0 (TD0) -> TXD0
		Pin 130 TXD1 (TD1) -> TXD1
		Pin 89 CLKOUT(CLKOUT) -> XI
		Pin 188 MDIO (MDIO) -> MDIO
		Pin 178 MDC (MDC) -> MDC

	IOs conflict with ecspi3 for MX7D_PAD_I2C2_SCL__CCM_ENET_REF_CLK2
	IOs conflict with flexcan2 for MX7D_PAD_GPIO1_IO14__ENET2_MDIO and MX7D_PAD_GPIO1_IO15__ENET2_MDC
	IOs conflict with pinctrl_gpio1 and pinctrl_gpio4 for others
	*/
	pinctrl_enet2: enet2grp {
		fsl,pins = <
			MX7D_PAD_EPDC_SDCE0__ENET2_RGMII_RX_CTL	0x73
			MX7D_PAD_EPDC_SDCLK__ENET2_RGMII_RD0	0x73
			MX7D_PAD_EPDC_SDLE__ENET2_RGMII_RD1		0x73
			MX7D_PAD_EPDC_SDCE1__ENET2_RX_ER		0x73

			MX7D_PAD_EPDC_GDRL__ENET2_RGMII_TX_CTL	0x73
			MX7D_PAD_EPDC_SDCE2__ENET2_RGMII_TD0	0x73
			MX7D_PAD_EPDC_SDCE3__ENET2_RGMII_TD1	0x73
			MX7D_PAD_I2C2_SCL__CCM_ENET_REF_CLK2	0x40000073
			MX7D_PAD_GPIO1_IO14__ENET2_MDIO			0x3
			MX7D_PAD_GPIO1_IO15__ENET2_MDC			0x3
		>;
	};

	/* Duplicated std setting with GPIO selected and 0x0 for mask */
	pinctrl_enet2_sleep: enet2sleepgrp {
		fsl,pins = <
			MX7D_PAD_EPDC_SDCE0__GPIO2_IO20	0x0
			MX7D_PAD_EPDC_SDCLK__GPIO2_IO16	0x0
			MX7D_PAD_EPDC_SDLE__GPIO2_IO17		0x0
			MX7D_PAD_EPDC_SDCE1__GPIO2_IO21	0x0

			MX7D_PAD_EPDC_GDRL__GPIO2_IO26		0x0
			MX7D_PAD_EPDC_SDCE2__GPIO2_IO22	0x0
			MX7D_PAD_EPDC_SDCE3__GPIO2_IO23	0x0
			MX7D_PAD_I2C2_SCL__GPIO4_IO10		0x0
			MX7D_PAD_GPIO1_IO14__GPIO1_IO14	0x0
			MX7D_PAD_GPIO1_IO15__GPIO1_IO15	0x0
		>;
	};

	pinctrl_gpio1: gpio1-grp {
		fsl,pins = <
			MX7D_PAD_SAI1_RX_SYNC__GPIO6_IO16	0x74 /* SODIMM 77 - Reset main board RL78*/
			MX7D_PAD_EPDC_DATA09__GPIO2_IO9		0x14 /* SODIMM 89 */
			MX7D_PAD_EPDC_DATA08__GPIO2_IO8		0x74 /* SODIMM 91 */
			MX7D_PAD_LCD_RESET__GPIO3_IO4		0x14 /* SODIMM 93 */
			MX7D_PAD_EPDC_DATA13__GPIO2_IO13	0x14 /* SODIMM 95 */
			MX7D_PAD_ENET1_RGMII_TXC__GPIO7_IO11	0x14 /* SODIMM 99 */
			MX7D_PAD_EPDC_DATA10__GPIO2_IO10	0x14 /* SODIMM 105 - External WDOG enable (not used) */
			MX7D_PAD_EPDC_DATA04__GPIO2_IO4		0x14 /* SODIMM 119 */
			MX7D_PAD_EPDC_DATA05__GPIO2_IO5		0x14 /* SODIMM 121 */
			MX7D_PAD_EPDC_DATA06__GPIO2_IO6		0x74 /* SODIMM 123 - LOW_BATT battery low when signal low */
			MX7D_PAD_EPDC_DATA07__GPIO2_IO7		0x74 /* SODIMM 125 - Reset the Carrier board */
			MX7D_PAD_UART3_RTS_B__GPIO4_IO6		0x14 /* SODIMM 131 */
			MX7D_PAD_SAI1_RX_DATA__GPIO6_IO12	0x14 /* SODIMM 169 */
			MX7D_PAD_SAI1_RX_BCLK__GPIO6_IO17	0x14 /* SODIMM 24 */
			MX7D_PAD_SD2_DATA2__GPIO5_IO16		0x74 /* SODIMM 100 - Reset RF board (not used) */
			MX7D_PAD_SD2_DATA3__GPIO5_IO17		0x74 /* SODIMM 102 - IRQ from RF board (not used) */
			MX7D_PAD_EPDC_GDSP__GPIO2_IO27		0x14 /* SODIMM 104 */
			MX7D_PAD_EPDC_SDSHR__GPIO2_IO19		0x14 /* SODIMM 120 */
			MX7D_PAD_EPDC_DATA14__GPIO2_IO14	0x14 /* SODIMM 126 */
			MX7D_PAD_EPDC_PWR_STAT__GPIO2_IO31	0x14 /* SODIMM 128 */
			MX7D_PAD_EPDC_DATA11__GPIO2_IO11	0x14 /* SODIMM 152 */
			MX7D_PAD_SD2_CLK__GPIO5_IO12		0x14 /* SODIMM 184 */
			MX7D_PAD_SD2_CMD__GPIO5_IO13		0x14 /* SODIMM 186 */
			MX7D_PAD_UART3_RX_DATA__GPIO4_IO4	0x7C /* SODIMM 21 - USBC_OC set as GPIO 100K PU Hysteresis enabled*/
			MX7D_PAD_UART3_TX_DATA__GPIO4_IO5       0x74 /* SODIMM 19 - USBC_P_EN set as GPIO GPIO 100K PU Hysteresis disabled */
			MX7D_PAD_I2C2_SDA__GPIO4_IO11		0x74 /* SODIMM 86 - Backlight Enable */
		>;
	};

	pinctrl_gpio2: gpio2-grp { /* On X22 Camera interface */
		fsl,pins = <
			MX7D_PAD_SD1_CD_B__GPIO5_IO0		0x74 /* SODIMM 69 */
			MX7D_PAD_I2C4_SDA__GPIO4_IO15		0x74 /* SODIMM 75 - Reset Ethernet controller */
			MX7D_PAD_I2C3_SCL__GPIO4_IO12		0x14 /* SODIMM 81 */
			MX7D_PAD_ECSPI2_MISO__GPIO4_IO22	0x14 /* SODIMM 85 */
			MX7D_PAD_ECSPI1_SS0__GPIO4_IO19		0x14 /* SODIMM 97 */
			MX7D_PAD_I2C3_SDA__GPIO4_IO13		0x14 /* SODIMM 94 */
			MX7D_PAD_I2C4_SCL__GPIO4_IO14		0x14 /* SODIMM 96 */
		>;
	};

	pinctrl_gpio3: gpio3-grp { /* RL78_IRQ3 - RL78_IRQ8 */
		fsl,pins = <
		>;
	};

	pinctrl_gpio4: gpio4-grp { /* Alternatively CAN2 */
		fsl,pins = <
		>;
	};

	pinctrl_gpio6: gpio6-grp { /* ATMEL MXT TOUCH */
		fsl,pins = <
			MX7D_PAD_EPDC_DATA15__GPIO2_IO15	0x14 /* SODIMM 107 */
		>;
	};

	pinctrl_i2ctouch: i2ctouch-grp  {
		fsl,pins = <
			MX7D_PAD_ECSPI1_MISO__GPIO4_IO18	0x74 /* SODIMM 79 - Touch screen Reset */
			MX7D_PAD_SD2_RESET_B__GPIO5_IO11	0x70 /* SODIMM 98 - Touch screen Interrupt */
		>;
	};

	pinctrl_pwm1: pwm1-grp {
		fsl,pins = <
			MX7D_PAD_GPIO1_IO08__PWM1_OUT		0x14	/* SODIMM 59 - Multiplexed with ECSPI2_MOSI */
			MX7D_PAD_ECSPI2_MOSI__GPIO4_IO21	0x14	/* SODIMM 59 */
		>;
	};

	pinctrl_pwm2: pwm2-grp {
		fsl,pins = <
			MX7D_PAD_GPIO1_IO09__PWM2_OUT		0x7C	/* SODIMM 28 - PWM for display brightness command */
		>;
	};

	pinctrl_pwm3: pwm3-grp {
		fsl,pins = <
			MX7D_PAD_GPIO1_IO10__PWM3_OUT		0x14	/* SODIMM 30 */
		>;
	};

	pinctrl_pwm4: pwm4-grp {
		fsl,pins = <
			MX7D_PAD_GPIO1_IO11__PWM4_OUT		0x14	/* SODIMM 67 - Multiplexed with ECSPI2_SCLK */
			MX7D_PAD_ECSPI2_SCLK__GPIO4_IO20	0x14
		>;
	};

	pinctrl_uart2: uart2-grp {
		fsl,pins = <
			MX7D_PAD_UART2_TX_DATA__UART2_DTE_RX 0x78	/* SODIMM 36 - UART_B (not used) */
			MX7D_PAD_UART2_RX_DATA__UART2_DTE_TX 0x78	/* SODIMM 38 - UART_B (not used) */
			MX7D_PAD_SAI2_RX_DATA__UART2_DTE_RTS 0x79	/* SODIMM 32 - UART_B CTS (not used) */
			MX7D_PAD_SAI2_TX_DATA__UART2_DTE_CTS 0x79	/* SODIMM 34 - UART_B RTS (not used) */
		>;
	};

	pinctrl_uart1: uart1-grp {
		fsl,pins = <
			MX7D_PAD_UART1_TX_DATA__UART1_DTE_RX	0x79
			MX7D_PAD_UART1_RX_DATA__UART1_DTE_TX	0x79
			MX7D_PAD_SAI2_TX_BCLK__UART1_DCE_RTS	0x79	/* SODIMM 27 - DebuG tool RTS */
			MX7D_PAD_SAI2_TX_SYNC__UART1_DCE_CTS	0x79	/* SODIMM 25 - Debut tool CTS */
		>;
	};


	pinctrl_rl78irq: rl78irq-grp  {
		fsl,pins = <			
			MX7D_PAD_EPDC_GDCLK__GPIO2_IO24		0x74 /* SODIMM 132 - RL78_IRQ1 */
			MX7D_PAD_EPDC_GDOE__GPIO2_IO25		0x74 /* SODIMM 134 - RL78_IRQ2 */
			MX7D_PAD_LCD_DATA18__GPIO3_IO23		0x74 /* SODIMM 136 - RL78_IRQ3 */
			MX7D_PAD_LCD_DATA19__GPIO3_IO24		0x74 /* SODIMM 138 - RL78_IRQ4 */
			MX7D_PAD_LCD_DATA20__GPIO3_IO25		0x74 /* SODIMM 140 - RL78_IRQ5 */
			MX7D_PAD_LCD_DATA21__GPIO3_IO26		0x74 /* SODIMM 142 - RL78_IRQ6 */
			MX7D_PAD_LCD_DATA22__GPIO3_IO27		0x74 /* SODIMM 144 - RL78_IRQ7 */
			MX7D_PAD_LCD_DATA23__GPIO3_IO28		0x74 /* SODIMM 146 - RL78_IRQ8 */
			MX7D_PAD_EPDC_DATA12__GPIO2_IO12	0x74 /* SODIMM 150 - RL78_IRQ9 */
			MX7D_PAD_ECSPI1_SCLK__GPIO4_IO16	0x74 /* SODIMM 101 - RL78_IRQ10 */
			MX7D_PAD_ECSPI1_MOSI__GPIO4_IO17	0x74 /* SODIMM 103 - RL78_IRQ11 */
			MX7D_PAD_EPDC_BDR0__GPIO2_IO28		0x74 /* SODIMM 106 - RL78_IRQ12 */
			MX7D_PAD_EPDC_BDR1__GPIO2_IO29		0x74 /* SODIMM 110 - RL78_IRQ13 */
			MX7D_PAD_EPDC_DATA00__GPIO2_IO0		0x74 /* SODIMM 111 - RL78_IRQ14 */
			MX7D_PAD_EPDC_PWR_COM__GPIO2_IO30	0x74 /* SODIMM 112 - RL78_IRQ15 */
			MX7D_PAD_EPDC_DATA01__GPIO2_IO1		0x74 /* SODIMM 113 - RL78_IRQ16 */
			MX7D_PAD_EPDC_DATA02__GPIO2_IO2		0x74 /* SODIMM 115 - RL78_IRQ17 */
			MX7D_PAD_EPDC_DATA03__GPIO2_IO3		0x74 /* SODIMM 117 - RL78_IRQ18 */
			MX7D_PAD_EPDC_SDOE__GPIO2_IO18		0x74 /* SODIMM 118 - RL78_IRQ19 */
		>;
	};
};

/ {	
	rl78_irq {
		/* Device that manages the interrupt lines used by RL78s */
		/* The used GPIOs are set as input, drive strenght = 0, slow slew rate, hysteresis disabled, 100 kOhm pull-up */
		/* Interrupts are set, in the device driver, to active on falling edge */
		compatible = "hach,rl78_irq";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_rl78irq>;
		status = "okay";
		gpios = <&gpio2 24 GPIO_ACTIVE_LOW>,	/* SODIMM 132 - RL78_IRQ1 */
			<&gpio2 25 GPIO_ACTIVE_LOW>,	/* SODIMM 134 - RL78_IRQ2 */
			<&gpio3 23 GPIO_ACTIVE_LOW>,	/* SODIMM 136 - RL78_IRQ3 */
			<&gpio3 24 GPIO_ACTIVE_LOW>,	/* SODIMM 138 - RL78_IRQ4 */
			<&gpio3 25 GPIO_ACTIVE_LOW>,	/* SODIMM 140 - RL78_IRQ5 */
			<&gpio3 26 GPIO_ACTIVE_LOW>,	/* SODIMM 142 - RL78_IRQ6 */
			<&gpio3 27 GPIO_ACTIVE_LOW>,	/* SODIMM 144 - RL78_IRQ7 */
			<&gpio3 28 GPIO_ACTIVE_LOW>,	/* SODIMM 146 - RL78_IRQ8 */
			<&gpio2 12 GPIO_ACTIVE_LOW>,	/* SODIMM 150 - RL78_IRQ9 */
			<&gpio4 16 GPIO_ACTIVE_LOW>,	/* SODIMM 101 - RL78_IRQ10 */
			<&gpio4 17 GPIO_ACTIVE_LOW>,	/* SODIMM 103 - RL78_IRQ11 */
			<&gpio2 28 GPIO_ACTIVE_LOW>,	/* SODIMM 106 - RL78_IRQ12 */
			<&gpio2 29 GPIO_ACTIVE_LOW>,	/* SODIMM 110 - RL78_IRQ13 */
			<&gpio2 0 GPIO_ACTIVE_LOW>,	/* SODIMM 111 - RL78_IRQ14 */
			<&gpio2 30 GPIO_ACTIVE_LOW>,	/* SODIMM 112 - RL78_IRQ15 */
			<&gpio2 1 GPIO_ACTIVE_LOW>,	/* SODIMM 113 - RL78_IRQ16 */
			<&gpio2 2 GPIO_ACTIVE_LOW>,	/* SODIMM 115 - RL78_IRQ17 */
			<&gpio2 3 GPIO_ACTIVE_LOW>,	/* SODIMM 117 - RL78_IRQ18 */
			<&gpio2 18 GPIO_ACTIVE_LOW>;	/* SODIMM 118 - RL78_IRQ19 */		
	};

};

/* Pins GPIO1_IO06 and GPIO1_IO07 are no more allocated to RI and DSR for uart1
 * Those pins are now allocated to I2C2
 * On I2C2 bus the light sensor and the capacitive touchpad are connected
 */
&uart1 {
	pinctrl-0 = <&pinctrl_uart1 &pinctrl_uart1_ctrl1>;
};

&iomuxc_lpsr {
	pinctrl_i2c2: i2c2-grp  {
		fsl,pins = <
			MX7D_PAD_GPIO1_IO07__I2C2_SDA	0x4000007f
			MX7D_PAD_GPIO1_IO06__I2C2_SCL	0x4000007f
		>;
	};

	pinctrl_gpio_lpsr: gpio1-grp {
		fsl,pins = <
			/* MX7D_PAD_GPIO1_IO02__GPIO1_IO2	0x14  SODIMM 135 */
			/* MX7D_PAD_GPIO1_IO03__GPIO1_IO3	0x14  SODIMM 22 */
			MX7D_PAD_GPIO1_IO01__GPIO1_IO1	0X74 /* SODIMM 45 - Reset USB HUB*/  
		>;
	};
};
/* Pin MX7D_PAD_I2C2_SDA__GPIO4_IO11 is no longer used as SPI3 CS.
 * This pin is now used as Backlight Enable signal.
 * It is configured properly in pinctrl_gpio1: gpio1-grp  
 */
&ecspi3 {
	pinctrl-0 = <&pinctrl_ecspi3>;

};
